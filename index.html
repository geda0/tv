<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3 & Beyond</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        canvas {
            display: block;
        }

        #model-selection {
            position: fixed;
            top: 70px;
            left: 0;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        #model-selection h4 {
            color: white;
        }

        .model-button {
            padding: 10px 20px;
            background-color: white;
            border: 1px solid black;
            border-radius: 5px;
            margin: 10px;
            cursor: pointer;
        }

        #hud {
            position: fixed;
            top: 10px;
            left: 60px;

        }

        #score {
            font-size: 21px;
            margin-bottom: 10px;
        }

        .color-picker {
            margin-bottom: 5px;
        }

        footer {
            background-color: #333;
            color: #fff;
            padding-bottom: 7px;
            text-align: center;
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            z-index: 999;
        }

        #startButton {
            width: 100px;
            height: 50px;
            position: absolute;
            top: 0;
            left: calc(50% - 50px);
            z-index: 100;
        }

        .question-mark-button {
            position: fixed;
            right: 20px;
            bottom: 20px;
            font-size: 24px;
            background-color: #6a0dad;
            color: #f5f5f5;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            z-index: 1000;
        }

        .info-box {
            position: fixed;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(44, 44, 44, 0.9);
            color: #f5f5f5;
            padding: 20px;
            border-radius: 10px;
        }

        .info-box h3 {
            margin-top: 0;
        }

        .close-button {
            position: absolute;
            top: 10px;
            right: 10px;
            cursor: pointer;
        }

        .gotit-button {
            position: absolute;
            bottom: 10px;
            right: 50px;
            cursor: pointer;
        }

        #close-info-box {
            background-color: #6a0dad;
            color: #f5f5f5;
            font-size: 16px;
            padding: 8px 16px;
            border: none;
            cursor: pointer;
            margin-top: 20px;
        }

        #close-info-box:hover {
            background-color: #4b0075;
        }

        footer p {
            margin: 0;
        }
    </style>
</head>

<body>
    <div id="model-selection">
        <h4>Deploy</h4>
        <button id="model-1" class="model-button">Glasses</button>
        <button id="model-2" class="model-button">OK</button>
        <button id="model-3" class="model-button">Remy</button>
    </div>
    <button id="startButton">Start talking!</button>

    <div id="hud">
        <label for="bgColorPicker" class="color-picker">Background Color:</label>
        <input type="color" id="bgColorPicker" class="color-picker" value="#119911">
        <label for="rainColorPicker" class="color-picker">Raindrop Color:</label>
        <input type="color" id="rainColorPicker" class="color-picker" value="#00f0ff">
    </div>
    <div class="question-mark-button" id="questionMarkButton">?</div>

    <div class="info-box" id="infoBox">
        <h3>Generative Video Platform -under construction-</h3>
        <p>
            Generative Video Platform ©, Is a platform for creators.
            Based on Thought Visualizer Technology ©.
            This platform is intended to generate creative scenes, which are represented in the 4th dimention (the speed
            of thought formation) or simply, time.

            While the platform is under construction still, you can experience the 4th by zomming out (after talking,
            an/or deploying)
            The deployed character will "run" "Play" "Stop" if you ask.
        </p>
        <span class="close-button" id="closeButton">&times;</span>
        <button id="close-info-box">OK</button>

    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.min.js"></script>
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.150.1/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.150.1/examples/jsm/"
        }
      }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';
        import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';

        class Settings {
            constructor() {
                this.raindropSize = 0.5;
                this.raindropSpeed = 5;
                this.rotationSpeed = 0.01;
                this.wPosition = 0;
                this.wRotation = 0;
            }
        }

        class Vector4 {
            constructor(x = 0, y = 0, z = 0, w = 0) {
                this.x = x;
                this.y = y;
                this.z = z;
                this.w = w;
            }

            add(v) {
                return new Vector4(this.x + v.x, this.y + v.y, this.z + v.z, this.w + v.w);
            }
        }

        class Matrix5 {
            constructor() {
                this.elements = new Float32Array(25).fill(0);
            }

            // Add matrix operations (multiplication, inversion, etc.) as needed...
        }

        class FourDCamera extends THREE.Camera {
            constructor(fov, aspect, near, far) {
                super();
                this.projectionMatrix = new Matrix5();
                // Set up the initial projection matrix
            }

            // Implement methods to update the projection matrix and other camera properties as needed...
        }

        class TesseractGeometry extends THREE.BufferGeometry {
            constructor() {
                super();
                // Generate 4D vertices, edges, and faces
                // Create custom vertex attributes for the 4D vertices and normals
            }
        }


        class Raindrop4D extends THREE.BufferGeometry {
            constructor(radius, widthSegments, heightSegments) {
                super();

                const raindropGeo = new THREE.SphereGeometry(radius, widthSegments, heightSegments);
                this.setIndex(raindropGeo.index);
                this.setAttribute('position', raindropGeo.getAttribute('position'));
                this.setAttribute('normal', raindropGeo.getAttribute('normal'));

                const vertexCount = raindropGeo.getAttribute('position').count;
                const position4D = new Float32Array(vertexCount * 4);
                const wValues = [0, 0, 0, 1]; // Modify these values to experiment with different 4D positions

                for (let i = 0; i < vertexCount; i++) {
                    const position3D = raindropGeo.getAttribute('position').array.slice(i * 3, i * 3 + 3);
                    position4D.set(position3D, i * 4);
                    position4D[i * 4 + 3] = wValues[i % 4];
                }

                this.setAttribute('position4D', new THREE.BufferAttribute(position4D, 4));
            }
        }



        class FourDMaterial extends THREE.ShaderMaterial {
            constructor() {
                const uniforms = THREE.UniformsUtils.merge([
                    THREE.UniformsLib.common,
                    {
                        projectionMatrix4D: { value: [new THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4()] },
                    },
                ]);


                const vertexShader = `
  attribute vec4 position4D;
  uniform vec4 projectionMatrix4D[4];
  varying vec3 vPosition;
  varying vec3 vNormal;
  void main() {
    vPosition = position;
    vNormal = normal;
    vec4 position3D = vec4(
      dot(position4D, projectionMatrix4D[0]),
      dot(position4D, projectionMatrix4D[1]),
      dot(position4D, projectionMatrix4D[2]),
      dot(position4D, projectionMatrix4D[3])
    );
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position3D.xyz, 1.0);
  }
`;


                const fragmentShader = `
    uniform vec3 diffuse;
    varying vec3 vPosition;
    varying vec3 vNormal;
    void main() {
    vec3 light = normalize(vec3(1.0, 1.0, 1.0));
    float brightness = max(dot(vNormal, light), 0.1);
    gl_FragColor = vec4(diffuse * brightness, 0.5);
    }
`;

                super({
                    uniforms: uniforms,
                    vertexShader: vertexShader,
                    fragmentShader: fragmentShader,
                    transparent: true,
                });
            }
        }


        class Four {

            constructor(container) {
                this.container = container;
                this.clock = clock;
                this.renderer = null;
                this.scene = null;
                this.camera = null;
                this.width = window.innerWidth;
                this.height = window.innerHeight;
                this.raindrops = [];
                this.initKeyboardControls();
                this.settings = new Settings();
            }

            initScene() {
                this.scene = new THREE.Scene();
            }

            initCamera() {
                this.camera = new THREE.PerspectiveCamera(75, this.width / this.height, 0.1, 1000);
                this.camera.position.z = 5;
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                this.render();
            }

            initKeyboardControls() {
                document.addEventListener('keydown', (event) => this.onKeyDown(event));
                document.addEventListener('keyup', (event) => this.onKeyUp(event));
            }

            updateRaindropSize() {
                for (const raindrop of this.raindrops) {
                    const newRaindropGeo = new Raindrop4D(this.settings.raindropSize, 8, 8);
                    raindrop.geometry.copy(newRaindropGeo);
                }
            }

            initObjects() {
                const raindrop = new Raindrop4D(this.settings.raindropSize, 8, 8);
                const material = new FourDMaterial();
                const mesh = new THREE.Mesh(raindrop, material);
                mesh.name = 'raindrop';
                this.scene.add(mesh);
            }

            onKeyDown(event) {
                if (event.code === 'ArrowUp') {
                    this.translateRaindrop4D(0.1);
                } else if (event.code === 'ArrowDown') {
                    this.translateRaindrop4D(-0.1);
                }
            }

            onKeyUp(event) {
                // Handle key up events (if needed)
            }

            translateRaindrop4D(dw) {
                dw = this.settings.wPosition;
                const raindrop = this.scene.getObjectByName('raindrop');
                if (!raindrop) return;
                const position4D = raindrop.geometry.getAttribute('position4D');
                for (let i = 0; i < position4D.count; i++) {
                    position4D.array[i * 4 + 3] += dw;
                }
                position4D.needsUpdate = true;
            }

            rotateScene4D() {
                const wRotation = this.settings.wRotation;
                const sinW = Math.sin(wRotation);
                const cosW = Math.cos(wRotation);

                for (const raindrop of this.raindrops) {
                    const position4D = raindrop.geometry.getAttribute('position4D');

                    for (let i = 0; i < position4D.count; i++) {
                        const z = position4D.array[i * 4 + 2];
                        const w = position4D.array[i * 4 + 3];

                        position4D.array[i * 4 + 2] = z * cosW - w * sinW;
                        position4D.array[i * 4 + 3] = z * sinW + w * cosW;
                    }

                    position4D.needsUpdate = true;
                }
            }


            start() {
                this.initRenderer();
                this.initScene();
                this.initCamera();
                this.animate();
                this.initObjects();
            }

            initRenderer() {
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(this.width, this.height);
                this.container.appendChild(this.renderer.domElement);
            }

            initObjects() {
                const numRaindrops = 100;

                for (let i = 0; i < numRaindrops; i++) {
                    const raindrop = new Raindrop4D(0.5, 8, 8);
                    const material = new FourDMaterial();
                    const mesh = new THREE.Mesh(raindrop, material);
                    mesh.position.set(Math.random() * 50 - 25, Math.random() * 50 - 25, Math.random() * 50 - 25);
                    mesh.userData.w = Math.random() * 50 - 25; // Set initial w-coordinate
                    this.raindrops.push(mesh);
                    this.scene.add(mesh);
                }
            }

            updateRaindrops(deltaTime) {
                const speed = this.settings.raindropSpeed;

                for (const raindrop of this.raindrops) {
                    raindrop.userData.w += deltaTime * speed;
                    const position4D = raindrop.geometry.getAttribute('position4D');

                    for (let i = 0; i < position4D.count; i++) {
                        position4D.array[i * 4 + 3] = raindrop.userData.w;
                    }

                    position4D.needsUpdate = true;
                }
            }


            rotateScene(deltaTime) {
                const rotationSpeed = this.settings.rotationSpeed;
                this.scene.rotation.x += rotationSpeed * deltaTime;
                this.scene.rotation.y += rotationSpeed * deltaTime;
            }

            render() {
                const deltaTime = this.clock.getDelta();
                this.updateRaindrops(deltaTime);
                this.rotateScene(deltaTime);
                this.rotateScene4D();
                this.renderer.render(this.scene, this.camera);
            }
        }


        document.addEventListener("DOMContentLoaded", function () {
            const container = document.getElementsByTagName("canvas")[0];
            const four = new Four(container);
            four.start();
        });

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 100, 250);

        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);

        const light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(0, 10, 10);
        scene.add(light);

        const loader = new FBXLoader();
        const clock = new THREE.Clock();
        let mixer;
        let character;
        let stickmanArmAngle = 0;
        let stickmanLegAngle = 0;
        const stickmanArmSpeed = 0.1;
        const stickmanLegSpeed = 0.15;

        const settings = {
            clearColor: '#119911',
            rainColor: '#00f0ff',
            rainCount: 9999,
            rainHeight: 500,
            rainSpeed: 4
        };

        const rainGeo = new THREE.SphereGeometry(0.5, 8, 8);
        const rainMaterial = new THREE.MeshBasicMaterial({ color: settings.rainColor, transparent: true, opacity: 0.5 });
        const rain = [];
        const rainHeight = settings.rainHeight;
        const rainSpeed = settings.rainSpeed;

        const bgColorPicker = document.getElementById('bgColorPicker');
        bgColorPicker.addEventListener('input', () => {
            renderer.setClearColor(bgColorPicker.value);
        });

        const rainColorPicker = document.getElementById('rainColorPicker');
        rainColorPicker.addEventListener('input', () => {
            settings.rainColor = rainColorPicker.value;
        });

        for (let i = 0; i < settings.rainCount; i++) {
            const raindrop = new THREE.Mesh(rainGeo, rainMaterial);
            raindrop.position.set(Math.random() * 400 - 200, Math.random() * rainHeight, Math.random() * 500 - 200);
            scene.add(raindrop);
            rain.push(raindrop);
        }

        function createStickman() {
            const stickmanMaterial = new THREE.MeshBasicMaterial({ color: 0x991199 });
            const head = new THREE.Mesh(new THREE.SphereGeometry(10), stickmanMaterial);
            const body = new THREE.Mesh(new THREE.CylinderGeometry(2, 2, 40), stickmanMaterial);
            const leg1 = new THREE.Mesh(new THREE.CylinderGeometry(2, 2, 40), stickmanMaterial);
            const leg2 = new THREE.Mesh(new THREE.CylinderGeometry(2, 2, 40), stickmanMaterial);
            const arm1 = new THREE.Mesh(new THREE.CylinderGeometry(2, 2, 40), stickmanMaterial);
            const arm2 = new THREE.Mesh(new THREE.CylinderGeometry(2, 2, 40), stickmanMaterial);
            head.position.y = 60;
            body.position.y = 30;
            leg1.position.set(0, 0, 10);
            leg2.position.set(0, 0, -10);
            arm1.position.set(0, 30, 20);
            arm2.position.set(0, 30, -20);
            leg1.rotation.x = Math.PI / 2;
            leg2.rotation.x = Math.PI / 2;
            arm1.rotation.z = Math.PI / 2;
            arm2.rotation.z = Math.PI / 2;

            const stickman = new THREE.Group();
            stickman.add(head);
            stickman.add(body);
            stickman.add(leg1);
            stickman.add(leg2);
            stickman.add(arm1);
            stickman.add(arm2);

            return stickman;
        }

        function updateCharacter(delta) {
            if (mixer) {
                mixer.update(delta);
            }
        }

        const model1Button = document.getElementById('model-1');
        const model2Button = document.getElementById('model-2');
        const model3Button = document.getElementById('model-3');
        const modelSelection = document.getElementById('model-selection');

        const stickman = createStickman();
        // Update model buttons event listeners
        function selectModel(modelPath) {
            modelSelection.style.display = 'none';
            scene.add(stickman);
            return loadCharacterModel(modelPath);
        }

        model1Button.addEventListener('click', () => selectModel('models/Ch03_nonPBR.fbx'));
        model2Button.addEventListener('click', () => selectModel('models/Remy.fbx'));
        model3Button.addEventListener('click', () => selectModel('models/Ch21_nonPBR.fbx'));


        function animateStickman() {
            stickmanArmAngle += stickmanArmSpeed;
            stickmanLegAngle += stickmanLegSpeed;
            stickman.children[4].rotation.x = Math.sin(stickmanArmAngle) * 0.5; // Left arm
            stickman.children[5].rotation.x = -Math.sin(stickmanArmAngle) * 0.5; // Right arm

            stickman.children[2].rotation.z = Math.sin(stickmanLegAngle) * 0.5; // Left leg
            stickman.children[3].rotation.z = -Math.sin(stickmanLegAngle) * 0.5; // Right leg
        }

        // Add the animation files to an array
        const animations = {
            walk: {
                names: ["Tpose", "nod", "walk"],
                steps: [

                    // Nod
                    { boneName: "head", rotation: { x: -5, y: 0, z: 0 }, duration: 300 },
                    { boneName: "head", rotation: { x: 0, y: 0, z: 0 }, duration: 300 },

                    // Begin walk cycle
                    // Left leg forward, right leg back
                    { boneName: "upperLegLeft", rotation: { x: -10, y: 0, z: 0 }, duration: 300 },
                    { boneName: "lowerLegLeft", rotation: { x: 20, y: 0, z: 0 }, duration: 300 },
                    { boneName: "upperLegRight", rotation: { x: 10, y: 0, z: 0 }, duration: 300 },
                    { boneName: "lowerLegRight", rotation: { x: -20, y: 0, z: 0 }, duration: 300 },

                    // Arms swing opposite to legs
                    { boneName: "upperArmLeft", rotation: { x: 0, y: 0, z: 10 }, duration: 300 },
                    { boneName: "upperArmRight", rotation: { x: 0, y: 0, z: -10 }, duration: 300 },

                    // Switch leg positions
                    { boneName: "upperLegLeft", rotation: { x: 10, y: 0, z: 0 }, duration: 300 },
                    { boneName: "lowerLegLeft", rotation: { x: -20, y: 0, z: 0 }, duration: 300 },
                    { boneName: "upperLegRight", rotation: { x: -10, y: 0, z: 0 }, duration: 300 },
                    { boneName: "lowerLegRight", rotation: { x: 20, y: 0, z: 0 }, duration: 300 },

                    // Arms swing opposite to legs
                    { boneName: "upperArmLeft", rotation: { x: 0, y: 0, z: -10 }, duration: 300 },
                    { boneName: "upperArmRight", rotation: { x: 0, y: 0, z: 10 }, duration: 300 },

                ],
                loop: true
            }

            ,
            run: {
                names: ["run"],
                steps: [ /* array of run animation steps */],
            },
            stand: {
                names: ["stand", "stop"],
                steps: [ /* array of stand animation steps */],
            },
            jump: {
                names: ["jump", "play", "up"],
                steps: [ /* array of jump animation steps */],
            },
            sit: {
                names: ["sit", "down", "sit down", "float", "yoga"],
                steps: [ /* array of sit animation steps */],
            },
        };

        // Helper function to animate a single bone
        function animateBone(bone, targetRotation, duration) {
            const currentRotation = bone.rotation.clone();
            const finalRotation = new THREE.Vector3().copy(currentRotation).add(targetRotation);

            const tween = new TWEEN.Tween(currentRotation)
                .to(finalRotation, duration)
                .easing(TWEEN.Easing.Quadratic.Out)
                .onUpdate(() => {
                    bone.rotation.set(currentRotation.x, currentRotation.y, currentRotation.z);
                })
                .start();
        }

        const boneTemplate = {
            head: /Head$/i,
            neck: /Neck$/i,
            spine: /Spine$/i,
            spine1: /Spine1$/i,
            spine2: /Spine2$/i,
            hips: /Hips$/i,
            upperArmLeft: /LeftArm$/i,
            lowerArmLeft: /LeftForeArm$/i,
            handLeft: /LeftHand$/i,
            upperArmRight: /RightArm$/i,
            lowerArmRight: /RightForeArm$/i,
            handRight: /RightHand$/i,
            shoulderLeft: /LeftShoulder$/i,
            shoulderRight: /RightShoulder$/i,
            upperLegLeft: /LeftUpLeg$/i,
            lowerLegLeft: /LeftLeg$/i,
            footLeft: /LeftFoot$/i,
            toeBaseLeft: /LeftToeBase$/i,
            upperLegRight: /RightUpLeg$/i,
            lowerLegRight: /RightLeg$/i,
            footRight: /RightFoot$/i,
            toeBaseRight: /RightToeBase$/i,

            // Additional hand bone parts for left and right hands
            handThumb1Left: /LeftHandThumb1$/i,
            handThumb2Left: /LeftHandThumb2$/i,
            handThumb3Left: /LeftHandThumb3$/i,
            handIndex1Left: /LeftHandIndex1$/i,
            handIndex2Left: /LeftHandIndex2$/i,
            handIndex3Left: /LeftHandIndex3$/i,
            handMiddle1Left: /LeftHandMiddle1$/i,
            handMiddle2Left: /LeftHandMiddle2$/i,
            handMiddle3Left: /LeftHandMiddle3$/i,
            handRing1Left: /LeftHandRing1$/i,
            handRing2Left: /LeftHandRing2$/i,
            handRing3Left: /LeftHandRing3$/i,
            handPinky1Left: /LeftHandPinky1$/i,
            handPinky2Left: /LeftHandPinky2$/i,
            handPinky3Left: /LeftHandPinky3$/i,

            handThumb1Right: /RightHandThumb1$/i,
            handThumb2Right: /RightHandThumb2$/i,
            handThumb3Right: /RightHandThumb3$/i,
            handIndex1Right: /RightHandIndex1$/i,
            handIndex2Right: /RightHandIndex2$/i,
            handIndex3Right: /RightHandIndex3$/i,
            handMiddle1Right: /RightHandMiddle1$/i,
            handMiddle2Right: /RightHandMiddle2$/i,
            handMiddle3Right: /RightHandMiddle3$/i,
            handRing1Right: /RightHandRing1$/i,
            handRing2Right: /RightHandRing2$/i,
            handRing3Right: /RightHandRing3$/i,
            handPinky1Right: /RightHandPinky1$/i,
            handPinky2Right: /RightHandPinky2$/i,
            handPinky3Right: /RightHandPinky3$/i,
            // Additional bones for facial expressions and head movements
            eyeLeft: /LeftEye$/i,
            eyeRight: /RightEye$/i,
            jaw: /Jaw$/i,
            browOuterUpLeft: /LeftBrowOuterUp$/i,
            browOuterUpRight: /RightBrowOuterUp$/i,
            browInnerUpLeft: /LeftBrowInnerUp$/i,
            browInnerUpRight: /RightBrowInnerUp$/i,
            cheekSquintLeft: /LeftCheekSquint$/i,
            cheekSquintRight: /RightCheekSquint$/i,
            noseSneerLeft: /LeftNoseSneer$/i,
            noseSneerRight: /RightNoseSneer$/i,
            lipCornerPullLeft: /LeftLipCornerPull$/i,
            lipCornerPullRight: /RightLipCornerPull$/i,
            lipCornerDepressorLeft: /LeftLipCornerDepressor$/i,
            lipCornerDepressorRight: /RightLipCornerDepressor$/i,
            lipLowerDownLeft: /LeftLipLowerDown$/i,
            lipLowerDownRight: /RightLipLowerDown$/i,
            lipUpperUpLeft: /LeftLipUpperUp$/i,
            lipUpperUpRight: /RightLipUpperUp$/i,
            lipPucker: /LipPucker$/i,
            lipPress: /LipPress$/i,

            // Additional bones for tail and wings if present
            tailBase: /TailBase$/i,
            tail1: /Tail1$/i,
            tail2: /Tail2$/i,
            tail3: /Tail3$/i,
            tail4: /Tail4$/i,
            wingBaseLeft: /LeftWingBase$/i,
            wing1Left: /LeftWing1$/i,
            wing2Left: /LeftWing2$/i,
            wing3Left: /LeftWing3$/i,
            wing4Left: /LeftWing4$/i,
            wingBaseRight: /RightWingBase$/i,
            wing1Right: /RightWing1$/i,
            wing2Right: /RightWing2$/i,
            wing3Right: /RightWing3$/i,
            wing4Right: /RightWing4$/i,
            // Additional bones for facial expressions and head movements
            eyeLeft: /LeftEye$/i,
            eyeRight: /RightEye$/i,
            jaw: /Jaw$/i,
            browOuterUpLeft: /LeftBrowOuterUp$/i,
            browOuterUpRight: /RightBrowOuterUp$/i,
            browInnerUpLeft: /LeftBrowInnerUp$/i,
            browInnerUpRight: /RightBrowInnerUp$/i,
            cheekSquintLeft: /LeftCheekSquint$/i,
            cheekSquintRight: /RightCheekSquint$/i,
            noseSneerLeft: /LeftNoseSneer$/i,
            noseSneerRight: /RightNoseSneer$/i,
            lipCornerPullLeft: /LeftLipCornerPull$/i,
            lipCornerPullRight: /RightLipCornerPull$/i,
            lipCornerDepressorLeft: /LeftLipCornerDepressor$/i,
            lipCornerDepressorRight: /RightLipCornerDepressor$/i,
            lipLowerDownLeft: /LeftLipLowerDown$/i,
            lipLowerDownRight: /RightLipLowerDown$/i,
            lipUpperUpLeft: /LeftLipUpperUp$/i,
            lipUpperUpRight: /RightLipUpperUp$/i,
            lipPucker: /LipPucker$/i,
            lipPress: /LipPress$/i,

            // Additional bones for tail and wings if present
            tailBase: /TailBase$/i,
            tail1: /Tail1$/i,
            tail2: /Tail2$/i,
            tail3: /Tail3$/i,
            tail4: /Tail4$/i,
            wingBaseLeft: /LeftWingBase$/i,
            wing1Left: /LeftWing1$/i,
            wing2Left: /LeftWing2$/i,
            wing3Left: /LeftWing3$/i,
            wing4Left: /LeftWing4$/i,
            wingBaseRight: /RightWingBase$/i,
            wing1Right: /RightWing1$/i,
            wing2Right: /RightWing2$/i,
            wing3Right: /RightWing3$/i,
            wing4Right: /RightWing4$/i,
        };

        function findBone(boneName, object3D) {
            const boneRegex = boneTemplate[boneName];
            if (!boneRegex) {
                console.warn(`Bone template not found for: ${boneName}`);
                return null;
            }
            return object3D.children.find((child) => boneRegex.test(child.name));
        }

        function detectBones(character) {
            if (!character) return;
            console.log(character);
            console.log(character.children);

            const bones = character.children[0].skeleton.bones;
            const detectedBones = {};
            console.log("bones: ", bones);

            for (const bone of bones) {
                for (const key in boneTemplate) {
                    if (boneTemplate[key].test(bone.name)) {
                        detectedBones[key] = bone;
                        break;
                    }
                }
            }

            console.log(detectedBones);
            return detectedBones;
        }

        // Function to play an animation
        async function playAnimation(animationName) {
            const animation = animations[animationName];
            if (!animation) {
                console.warn(`Animation "${animationName}" not found.`);
                return;
            }

            for (const animStep of animation.steps) {
                const { boneName, rotation, duration } = animStep;
                console.log("CBones: ", characterBones);
                const bone = characterBones[boneName];
                if (!bone) {
                    console.warn(`Bone "${boneName}" not found.`);
                    continue;
                } else console.log(`animating${boneName}`);

                animateBone(bone, rotation, duration);
                await new Promise(resolve => setTimeout(resolve, duration));
            }
        }


        let activeAnimationIndex = 0;

        let characterBones = [];

        let actions = [];


        async function loadCharacterModel(modelPath) {
            return new Promise((resolve, reject) => {
                loader.load(modelPath, async (object) => {
                    mixer = new THREE.AnimationMixer(object);
                    character = object;
                    character.position.set(0, 0, 0);
                    scene.remove(stickman);
                    scene.add(character);
                    characterBones = detectBones(character);

                    resolve();
                    // recognition.start(); // Restart speech recognition after the model is loaded
                }, undefined, reject);
            });
        }


        // Create circles for each animation
        // const circleContainer = document.createElement('div');
        // circleContainer.style.position = 'fixed';
        // circleContainer.style.top = '10px';
        // circleContainer.style.left = '10px';
        // document.body.appendChild(circleContainer);

        // animations.forEach((animation, index) => {
        //     const circle = document.createElement('div');
        //     circle.id = 'circle-' + index;
        //     circle.style.width = '20px';
        //     circle.style.height = '20px';
        //     circle.style.border = '2px solid transparent';
        //     circle.style.borderRadius = '50%';
        //     circle.style.backgroundColor = 'red';
        //     circle.style.marginRight = '5px';
        //     circleContainer.appendChild(circle);

        //     circle.addEventListener('click', () => {
        //         playAnimation(index);
        //     });
        // });

        const animate = function () {
            requestAnimationFrame(animate);
            TWEEN.update();
            const delta = clock.getDelta();
            animateStickman();
            if (mixer) {
                mixer.update(delta);
            }
            updateCharacter(delta);

            const rainColor = new THREE.Color(settings.rainColor);
            for (let i = 0; i < rain.length; i++) {
                const raindrop = rain[i];
                raindrop.position.y -= rainSpeed;
                if (raindrop.position.y < 0) {
                    raindrop.position.y = Math.random() * rainHeight;
                }
                raindrop.material.color.set(rainColor);
            }

            controls.update();
            renderer.render(scene, camera);
            updateCanvas();
        };

        // Add the speech recognition initialization code
        const recognition = new (window.SpeechRecognition ||
            window.webkitSpeechRecognition ||
            window.mozSpeechRecognition ||
            window.msSpeechRecognition)();
        recognition.lang = "en-US";
        recognition.interimResults = true;
        recognition.lang = 'en-US';

        const startButton = document.getElementById("startButton");
        startButton.addEventListener("click", function () {
            startButton.style.display = 'none';
            recognition.start();
            recognition.onresult = function (event) {
                const transcript = event.results[0][0].transcript;
                drawScene(transcript);
            };
        });

        recognition.onend = function () {
            recognition.start();
        };

        // Modify the drawScene function
        let canvasWords = [];

        function drawScene(transcript) {
            const words = transcript.split(" ");
            // Load the Helvetiker font
            const fontLoader = new FontLoader();
            fontLoader.load("https://threejs.org/examples/fonts/helvetiker_regular.typeface.json", function (font) {
                // Create a TextGeometry with the font

                words.forEach(word => {
                    // Check if the recognized word matches any of the keywords
                    const animationName = word.toLowerCase();

                    for (const animKey in animations) {
                        const animation = animations[animKey];

                        if (animation.names.includes(animationName)) {
                            playAnimation(animKey);
                            break;
                        }
                    }

                    const textGeometry = new TextGeometry(word, {
                        font: font,
                        size: 10,
                        height: 1
                    });
                    const textMaterial = new THREE.MeshBasicMaterial({ color: randomColor() });
                    const textMesh = new THREE.Mesh(textGeometry, textMaterial);
                    textMesh.position.set(
                        Math.random() * 400 - 200,
                        Math.random() * 200,
                        Math.random() * 500 - 200
                    );
                    scene.add(textMesh);
                    canvasWords.push({
                        mesh: textMesh,
                        time: Date.now()
                    });
                });
            });

        }


        // Add the randomColor function
        function randomColor() {
            return '#' + ((Math.random() * 0xffffff) << 0).toString(16);
        }


        // Replace the 2D canvas rendering with the 3D scene rendering
        function updateCanvas() {
            let i = 0;
            const currentTime = Date.now(); // Use Date.now() instead of clock.getElapsedTime() * 1000

            while (i < canvasWords.length) {
                const word = canvasWords[i];
                if (currentTime - word.time >= 6000) {
                    scene.remove(word.mesh);
                    canvasWords.splice(i, 1);
                } else {
                    i++;
                }
            }

            requestAnimationFrame(updateCanvas);
        }



        const questionMarkButton = document.getElementById('questionMarkButton');
        const infoBox = document.getElementById('infoBox');
        const closeButton = document.getElementById('closeButton');
        const okbutton = document.getElementById('close-info-box')

        questionMarkButton.addEventListener('click', () => {
            infoBox.style.display = 'block';
        });

        closeButton.addEventListener('click', () => {
            infoBox.style.display = 'none';
        });
        okbutton.addEventListener('click', () => {
            infoBox.style.display = 'none';
        });

        updateCanvas();

        animate();
    </script>

</body>
<footer>
    <p>© 2023 ME. All rights reserved.</p>
    <p><a href="https://www.linkedin.com$/in/marwan-elgendy/">LinkedIn</a> | <a
            href="mailto:marwan.gendy@gmail.com">marwan.gendy@gmail.com</a></p>
</footer>

</html>